<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avoid::Router Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<style>
pre { 
    border: dotted 1px #900; 
    padding: 5px; 
    background-color: #ffe;
}
a.anchor:hover {
    text-decoration: none;
}
</style>
</head>
<body>
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_avoid.html">Avoid</a></li><li class="navelem"><a class="el" href="class_avoid_1_1_router.html">Router</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_avoid_1_1_router-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Avoid::Router Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> class represents a libavoid router instance.  
 <a href="class_avoid_1_1_router.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="router_8h_source.html">router.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae0b300221fbff0d5539ef42e99d8714"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aae0b300221fbff0d5539ef42e99d8714">Router</a> (const unsigned int flags)</td></tr>
<tr class="memdesc:aae0b300221fbff0d5539ef42e99d8714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for router instance.  <a href="#aae0b300221fbff0d5539ef42e99d8714"></a><br/></td></tr>
<tr class="separator:aae0b300221fbff0d5539ef42e99d8714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415aa6409ec5d573bcdb90b1ce73e020"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a415aa6409ec5d573bcdb90b1ce73e020">~Router</a> ()</td></tr>
<tr class="memdesc:a415aa6409ec5d573bcdb90b1ce73e020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for router instance.  <a href="#a415aa6409ec5d573bcdb90b1ce73e020"></a><br/></td></tr>
<tr class="separator:a415aa6409ec5d573bcdb90b1ce73e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2908173631381499be763ea0b0dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad">setTransactionUse</a> (const bool transactions)</td></tr>
<tr class="memdesc:a74b2908173631381499be763ea0b0dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting of the behaviour of the router in regard to transactions. This controls whether transactions are used to queue changes and process them efficiently at once or they are instead processed immediately.  <a href="#a74b2908173631381499be763ea0b0dad"></a><br/></td></tr>
<tr class="separator:a74b2908173631381499be763ea0b0dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa322ef199e508ea8a7b74a29b4ab846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aaa322ef199e508ea8a7b74a29b4ab846">transactionUse</a> (void) const </td></tr>
<tr class="memdesc:aaa322ef199e508ea8a7b74a29b4ab846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the router groups actions into transactions.  <a href="#aaa322ef199e508ea8a7b74a29b4ab846"></a><br/></td></tr>
<tr class="separator:aaa322ef199e508ea8a7b74a29b4ab846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4497126d8d4c76a122af565260941fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc">processTransaction</a> (void)</td></tr>
<tr class="memdesc:ac4497126d8d4c76a122af565260941fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the current transaction and processes all the queued object changes efficiently.  <a href="#ac4497126d8d4c76a122af565260941fc"></a><br/></td></tr>
<tr class="separator:ac4497126d8d4c76a122af565260941fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f91cdcf5dc6ca0ec278e7943f8f21a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a1f91cdcf5dc6ca0ec278e7943f8f21a5">deleteShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape)</td></tr>
<tr class="memdesc:a1f91cdcf5dc6ca0ec278e7943f8f21a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a shape from the router scene.  <a href="#a1f91cdcf5dc6ca0ec278e7943f8f21a5"></a><br/></td></tr>
<tr class="separator:a1f91cdcf5dc6ca0ec278e7943f8f21a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766c0dd498c38822cf9ea7c77af28b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a766c0dd498c38822cf9ea7c77af28b3d">moveShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape, const <a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;newPoly, const bool first_move=false)</td></tr>
<tr class="memdesc:a766c0dd498c38822cf9ea7c77af28b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move or resize an existing shape within the router scene.  <a href="#a766c0dd498c38822cf9ea7c77af28b3d"></a><br/></td></tr>
<tr class="separator:a766c0dd498c38822cf9ea7c77af28b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac171735c187b3e0ea8f03fda4424fd4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ac171735c187b3e0ea8f03fda4424fd4f">moveShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape, const double xDiff, const double yDiff)</td></tr>
<tr class="memdesc:ac171735c187b3e0ea8f03fda4424fd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing shape within the router scene by a relative distance.  <a href="#ac171735c187b3e0ea8f03fda4424fd4f"></a><br/></td></tr>
<tr class="separator:ac171735c187b3e0ea8f03fda4424fd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b044531d3dc81fa76819e55917924b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a5b044531d3dc81fa76819e55917924b0">deleteJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction)</td></tr>
<tr class="memdesc:a5b044531d3dc81fa76819e55917924b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a junction from the router scene.  <a href="#a5b044531d3dc81fa76819e55917924b0"></a><br/></td></tr>
<tr class="separator:a5b044531d3dc81fa76819e55917924b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316f15b3e974c273bb55cfb19b751394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394">deleteConnector</a> (<a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> *connector)</td></tr>
<tr class="memdesc:a316f15b3e974c273bb55cfb19b751394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a connector from the router scene.  <a href="#a316f15b3e974c273bb55cfb19b751394"></a><br/></td></tr>
<tr class="separator:a316f15b3e974c273bb55cfb19b751394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08021cac275575c7795e2005e5eadb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a08021cac275575c7795e2005e5eadb9a">moveJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction, const <a class="el" href="class_avoid_1_1_point.html">Point</a> &amp;newPosition)</td></tr>
<tr class="memdesc:a08021cac275575c7795e2005e5eadb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing junction within the router scene.  <a href="#a08021cac275575c7795e2005e5eadb9a"></a><br/></td></tr>
<tr class="separator:a08021cac275575c7795e2005e5eadb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e5639b590902b5e734a1068fdc663c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a94e5639b590902b5e734a1068fdc663c">moveJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction, const double xDiff, const double yDiff)</td></tr>
<tr class="memdesc:a94e5639b590902b5e734a1068fdc663c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing junction within the router scene by a relative distance.  <a href="#a94e5639b590902b5e734a1068fdc663c"></a><br/></td></tr>
<tr class="separator:a94e5639b590902b5e734a1068fdc663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596cecf98ff1b40a8ee5c703e175ff62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a596cecf98ff1b40a8ee5c703e175ff62">setRoutingParameter</a> (const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a> parameter, const double value=chooseSensibleParamValue)</td></tr>
<tr class="memdesc:a596cecf98ff1b40a8ee5c703e175ff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values for routing parameters, including routing penalties.  <a href="#a596cecf98ff1b40a8ee5c703e175ff62"></a><br/></td></tr>
<tr class="separator:a596cecf98ff1b40a8ee5c703e175ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46f38002d1f54afffe1fc5123896da9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aa46f38002d1f54afffe1fc5123896da9">routingParameter</a> (const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a> parameter) const </td></tr>
<tr class="memdesc:aa46f38002d1f54afffe1fc5123896da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value for a particular routing parameter of a given type.  <a href="#aa46f38002d1f54afffe1fc5123896da9"></a><br/></td></tr>
<tr class="separator:aa46f38002d1f54afffe1fc5123896da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f057f6d101f010588c9022893c9ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a09f057f6d101f010588c9022893c9ac1">setRoutingOption</a> (const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a> option, const bool value)</td></tr>
<tr class="memdesc:a09f057f6d101f010588c9022893c9ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn specific routing options on or off.  <a href="#a09f057f6d101f010588c9022893c9ac1"></a><br/></td></tr>
<tr class="separator:a09f057f6d101f010588c9022893c9ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201845856b5b3ec6b868814b042cbc7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a201845856b5b3ec6b868814b042cbc7d">routingOption</a> (const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a> option) const </td></tr>
<tr class="memdesc:a201845856b5b3ec6b868814b042cbc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state for a specific routing option.  <a href="#a201845856b5b3ec6b868814b042cbc7d"></a><br/></td></tr>
<tr class="separator:a201845856b5b3ec6b868814b042cbc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbda0590ff3234faad409e2f39e1c9ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#acbda0590ff3234faad409e2f39e1c9ec">setRoutingPenalty</a> (const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a> penType, const double penVal=chooseSensibleParamValue)</td></tr>
<tr class="memdesc:acbda0590ff3234faad409e2f39e1c9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or removes penalty values that are applied during connector routing.  <a href="#acbda0590ff3234faad409e2f39e1c9ec"></a><br/></td></tr>
<tr class="separator:acbda0590ff3234faad409e2f39e1c9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc66cd795e86d921da1e8d9cb8a5c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_avoid_1_1_hyperedge_rerouter.html">HyperedgeRerouter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a3fc66cd795e86d921da1e8d9cb8a5c21">hyperedgeRerouter</a> (void)</td></tr>
<tr class="memdesc:a3fc66cd795e86d921da1e8d9cb8a5c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the hyperedge rerouter for the router.  <a href="#a3fc66cd795e86d921da1e8d9cb8a5c21"></a><br/></td></tr>
<tr class="separator:a3fc66cd795e86d921da1e8d9cb8a5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458aae2d6447e0958e4916a8c29bbb47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a458aae2d6447e0958e4916a8c29bbb47">outputInstanceToSVG</a> (std::string filename=std::string())</td></tr>
<tr class="memdesc:a458aae2d6447e0958e4916a8c29bbb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an SVG file containing debug output and code that can be used to regenerate the instance.  <a href="#a458aae2d6447e0958e4916a8c29bbb47"></a><br/></td></tr>
<tr class="separator:a458aae2d6447e0958e4916a8c29bbb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a244b93ca4f0eed883c534526a8d0aa"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a2a244b93ca4f0eed883c534526a8d0aa">newObjectId</a> (void) const </td></tr>
<tr class="memdesc:a2a244b93ca4f0eed883c534526a8d0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object ID used for automatically generated objects, such as during hyperedge routing.  <a href="#a2a244b93ca4f0eed883c534526a8d0aa"></a><br/></td></tr>
<tr class="separator:a2a244b93ca4f0eed883c534526a8d0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01a7615ac4efce64287642381d9ba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a6d01a7615ac4efce64287642381d9ba0">objectIdIsUnused</a> (const unsigned int id) const </td></tr>
<tr class="memdesc:a6d01a7615ac4efce64287642381d9ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the given ID is already used.  <a href="#a6d01a7615ac4efce64287642381d9ba0"></a><br/></td></tr>
<tr class="separator:a6d01a7615ac4efce64287642381d9ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f9094d991d09d25dd795b1254cfcf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a23f9094d991d09d25dd795b1254cfcf4">setSlowRoutingCallback</a> (bool(*func)(unsigned int, double))</td></tr>
<tr class="memdesc:a23f9094d991d09d25dd795b1254cfcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback function that will be called during slow, expensive connector rerouting.  <a href="#a23f9094d991d09d25dd795b1254cfcf4"></a><br/></td></tr>
<tr class="separator:a23f9094d991d09d25dd795b1254cfcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> class represents a libavoid router instance. </p>
<p>Usually you would keep a separate <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> instance for each diagram or layout you have open in your application. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aae0b300221fbff0d5539ef42e99d8714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::Router::Router </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for router instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>One or more <a class="el" href="namespace_avoid.html#a8b398574e5b64951b7f23a36a1cdfcf4" title="Flags that can be passed to the router during initialisation to specify options.">Avoid::RouterFlag</a> options to control the behaviour of the router. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a415aa6409ec5d573bcdb90b1ce73e020"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::Router::~Router </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor for router instance. </p>
<dl class="section note"><dt>Note</dt><dd>Destroying a router instance will delete all remaining shapes and connectors, thereby invalidating any existing pointers to them. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a316f15b3e974c273bb55cfb19b751394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::deleteConnector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> *&#160;</td>
          <td class="paramname"><em>connector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a connector from the router scene. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<p>You should not use the connector reference again after this call. The router will handle freeing of the connector's memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connector</td><td>Pointer reference to the connector being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b044531d3dc81fa76819e55917924b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::deleteJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a junction from the router scene. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<p>You should not use the junction reference again after this call. The router will handle freeing of the junction's memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f91cdcf5dc6ca0ec278e7943f8f21a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::deleteShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a shape from the router scene. </p>
<p>Connectors that could have a better (usually shorter) path after the removal of this shape will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<p>You should not use the shape reference again after this call. The router will handle freeing of the shape's memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fc66cd795e86d921da1e8d9cb8a5c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_hyperedge_rerouter.html">HyperedgeRerouter</a> * Avoid::Router::hyperedgeRerouter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the hyperedge rerouter for the router. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_avoid_1_1_hyperedge_rerouter.html" title="The HyperedgeRerouter class is a convenience object that can be used to register hyperedges to be rer...">HyperedgeRerouter</a> object that can be used to register hyperedges for rerouting. </dd></dl>

</div>
</div>
<a class="anchor" id="a08021cac275575c7795e2005e5eadb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>newPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing junction within the router scene. </p>
<p>Connectors that are attached to this junction will be rerouted as a result of the move.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPosition</td><td>The new position for the junction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94e5639b590902b5e734a1068fdc663c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>yDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing junction within the router scene by a relative distance. </p>
<p>Connectors that are attached to this junction will be rerouted as a result of the move.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDiff</td><td>The distance to move the junction in the x dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yDiff</td><td>The distance to move the junction in the y dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a766c0dd498c38822cf9ea7c77af28b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>first_move</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move or resize an existing shape within the router scene. </p>
<p>A new polygon for the shape can be given to effectively move or resize the shape with the scene. Connectors that intersect the new shape polygon, or that could have a better (usually shorter) path after the change, will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being moved/resized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPoly</td><td>The new polygon boundary for the shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_move</td><td>This option is used for some advanced (currently undocumented) behaviour and it should be ignored for the moment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac171735c187b3e0ea8f03fda4424fd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>yDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing shape within the router scene by a relative distance. </p>
<p>Connectors that intersect the shape's new position, or that could have a better (usually shorter) path after the change, will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDiff</td><td>The distance to move the shape in the x dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yDiff</td><td>The distance to move the shape in the y dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a244b93ca4f0eed883c534526a8d0aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Avoid::Router::newObjectId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object ID used for automatically generated objects, such as during hyperedge routing. </p>
<p>Reimplement this in a subclass to set specific IDs for new objects.</p>
<dl class="section note"><dt>Note</dt><dd>Your implementation should return a value that does not fail <a class="el" href="class_avoid_1_1_router.html#a6d01a7615ac4efce64287642381d9ba0" title="Returns whether or not the given ID is already used.">objectIdIsUnused()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The ID for a new object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d01a7615ac4efce64287642381d9ba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::objectIdIsUnused </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not the given ID is already used. </p>
<p>You should only need this if you reimplement <a class="el" href="class_avoid_1_1_router.html#a2a244b93ca4f0eed883c534526a8d0aa" title="Returns the object ID used for automatically generated objects, such as during hyperedge routing...">newObjectId()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>An ID to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean denoting that the given ID is unused. </dd></dl>

</div>
</div>
<a class="anchor" id="a458aae2d6447e0958e4916a8c29bbb47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::outputInstanceToSVG </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an SVG file containing debug output and code that can be used to regenerate the instance. </p>
<p>If transactions are being used, then this method should be called after <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> has been called, so that it includes any changes being queued by the router.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename to use for the output file, if not given "libavoid-debug.svg" will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4497126d8d4c76a122af565260941fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::processTransaction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes the current transaction and processes all the queued object changes efficiently. </p>
<p>This method will efficiently process all moves, additions and deletions that have occurred since <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> was last called.</p>
<p>If <a class="el" href="class_avoid_1_1_router.html#aaa322ef199e508ea8a7b74a29b4ab846" title="Reports whether the router groups actions into transactions.">transactionUse()</a> is false, then all actions will have been processed immediately and this method will do nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value describing whether there were any actions to process.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">setTransactionUse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a201845856b5b3ec6b868814b042cbc7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::routingOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state for a specific routing option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>The type of routing option, a RoutingOption. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing the option state. </dd></dl>

</div>
</div>
<a class="anchor" id="aa46f38002d1f54afffe1fc5123896da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Avoid::Router::routingParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a>&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value for a particular routing parameter of a given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The type of parameter, a RoutingParameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value for the specified routing parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a09f057f6d101f010588c9022893c9ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setRoutingOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn specific routing options on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>The type of routing option, a RoutingOption. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A boolean representing the option state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a596cecf98ff1b40a8ee5c703e175ff62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setRoutingParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a>&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em> = <code>chooseSensibleParamValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets values for routing parameters, including routing penalties. </p>
<p>libavoid uses a set of parameters to allow the user more control over routing style and quality. These different parameters are described and explained by the RoutingParameter enum. All parameters have sensible defaults.</p>
<p>Regarding routing penalties, libavoid will by default produce shortest path routes between the source and destination points for each connector. There are several penalties that can be applied during this stage to penalise certain conditions and thus improve the aesthetics of the routes generated.</p>
<p>If a value of zero or Avoid::zeroParamValue is given then the particular parameter value or penalty will be removed. If no parameter value argument (or a negative value) is specified when calling this method, then a sensible penalty value will be automatically chosen.</p>
<p>This method does not re-trigger processing of connectors. The new parameter value will be used the next time rerouting is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The type of penalty, a RoutingParameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set for that parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbda0590ff3234faad409e2f39e1c9ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setRoutingPenalty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a>&#160;</td>
          <td class="paramname"><em>penType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>penVal</em> = <code>chooseSensibleParamValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or removes penalty values that are applied during connector routing. </p>
<dl class="section note"><dt>Note</dt><dd>This is a convenience wrapper for the <a class="el" href="class_avoid_1_1_router.html#a596cecf98ff1b40a8ee5c703e175ff62" title="Sets values for routing parameters, including routing penalties.">setRoutingParameter()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">penType</td><td>The type of penalty, a RoutingParameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">penVal</td><td>The value to be applied for each occurrence of the penalty case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23f9094d991d09d25dd795b1254cfcf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setSlowRoutingCallback </td>
          <td>(</td>
          <td class="paramtype">bool(*)(unsigned int, double)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback function that will be called during slow, expensive connector rerouting. </p>
<p>If set, this function will be called approximately once a second during slow connector rerouting with crossing or shared path penalties.</p>
<p>The function will be passed as arguments the elapsed time in msec, and the estimated percentage completeness. It should return a boolean value indicating whether the router should continue using expensive crossing penalties or reroute the remaining connectors without the crossing and shared path penalties. If the function returns false, it will still be continued to be called to indicate completeness of the connector rerouting but the return value will be ignored for the rest of the transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer for the function to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74b2908173631381499be763ea0b0dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setTransactionUse </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transactions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows setting of the behaviour of the router in regard to transactions. This controls whether transactions are used to queue changes and process them efficiently at once or they are instead processed immediately. </p>
<p>It is more efficient to perform actions like shape movement, addition or deletion as batch tasks, and reroute the necessary connectors just once after these actions have been performed. For this reason, libavoid allows you to group such actions into "transactions" that are processed efficiently when the <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> method is called.</p>
<p>By default, the router will process all actions as transactions. If <a class="el" href="class_avoid_1_1_router.html#aaa322ef199e508ea8a7b74a29b4ab846" title="Reports whether the router groups actions into transactions.">transactionUse()</a> is set to false, then all actions will get processed immediately, and cause immediate routing callbacks to all affected connectors after each action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transactions</td><td>A boolean value specifying whether to use transactions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa322ef199e508ea8a7b74a29b4ab846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::transactionUse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the router groups actions into transactions. </p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value describing whether transactions are in use.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">setTransactionUse</a> </dd>
<dd>
<a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="router_8h_source.html">router.h</a></li>
<li>router.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 21 2013 00:12:59 for libavoid by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
